#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');

class RepresentativesAppHotfix {
  constructor() {
    this.appName = 'RepresentativesApp';
    this.version = '1.0.2.1';
    this.installPath = null;
    this.backupPath = null;
    this.logMessages = [];
    
    // Arquivos que ser√£o atualizados
    this.filesToUpdate = [
      {
        source: 'license-manager.js',
        target: '.next/server/chunks/[id].js', // Caminho ser√° detectado dinamicamente
        description: 'Sistema de licenciamento corrigido'
      },
      {
        source: 'license-recovery.js', 
        target: '.next/server/chunks/[id].js', // Novo arquivo
        description: 'Ferramentas de recupera√ß√£o'
      },
      {
        source: 'layout.js',
        target: '.next/server/app/layout.js',
        description: 'Interface com bypass autom√°tico'
      }
    ];
  }

  // üìù Sistema de logging
  log(message, type = 'info') {
    const timestamp = new Date().toISOString();
    const logEntry = { timestamp, type, message };
    this.logMessages.push(logEntry);
    
    const prefix = {
      'info': '‚úÖ',
      'warning': '‚ö†Ô∏è', 
      'error': '‚ùå',
      'progress': 'üîÑ'
    }[type] || '‚ÑπÔ∏è';
    
    console.log(`${prefix} ${message}`);
  }

  // üîç Detectar instala√ß√£o existente
  async detectInstallation() {
    this.log('Detectando instala√ß√£o do Representatives App...', 'progress');
    
    const possiblePaths = [
      path.join(os.homedir(), 'AppData', 'Local', this.appName),
      path.join(os.homedir(), 'AppData', 'Roaming', this.appName),
      path.join('C:', 'Program Files', this.appName),
      path.join('C:', 'Program Files (x86)', this.appName),
      path.join(os.homedir(), 'Desktop', this.appName),
      path.join(os.homedir(), 'Downloads', this.appName)
    ];

    for (const testPath of possiblePaths) {
      try {
        if (fs.existsSync(testPath)) {
          // Verificar se √© uma instala√ß√£o v√°lida
          const markers = [
            path.join(testPath, '.next'),
            path.join(testPath, 'package.json'),
            path.join(testPath, 'node-portable'),
            path.join(testPath, 'server.js')
          ];
          
          const validMarkers = markers.filter(marker => fs.existsSync(marker));
          
          if (validMarkers.length >= 2) {
            this.installPath = testPath;
            this.log(`Instala√ß√£o encontrada: ${testPath}`, 'info');
            
            // Verificar vers√£o se poss√≠vel
            try {
              const packagePath = path.join(testPath, 'package.json');
              if (fs.existsSync(packagePath)) {
                const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
                this.log(`Vers√£o atual: ${packageData.version || 'desconhecida'}`, 'info');
              }
            } catch (error) {
              // Ignorar erro de vers√£o
            }
            
            return true;
          }
        }
      } catch (error) {
        // Continuar procurando
      }
    }

    this.log('‚ùå Instala√ß√£o do Representatives App n√£o encontrada!', 'error');
    this.log('Certifique-se de que o aplicativo est√° instalado antes de executar este hotfix.', 'error');
    return false;
  }

  // üíæ Criar backup dos arquivos atuais
  async createBackup() {
    this.log('Criando backup dos arquivos atuais...', 'progress');
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.backupPath = path.join(this.installPath, 'backup', `hotfix-backup-${timestamp}`);
    
    try {
      // Criar diret√≥rio de backup
      fs.mkdirSync(this.backupPath, { recursive: true });
      
      let backedUpFiles = 0;
      
      // Backup do diret√≥rio .next completo (compactado)
      const nextPath = path.join(this.installPath, '.next');
      if (fs.existsSync(nextPath)) {
        const backupNextPath = path.join(this.backupPath, '.next');
        await this.copyDirectory(nextPath, backupNextPath);
        backedUpFiles++;
        this.log('Backup do build Next.js criado', 'info');
      }

      // Backup de arquivos importantes individuais
      const importantFiles = [
        'package.json',
        'server.js', 
        '.env'
      ];

      for (const file of importantFiles) {
        const sourcePath = path.join(this.installPath, file);
        const backupFilePath = path.join(this.backupPath, file);
        
        if (fs.existsSync(sourcePath)) {
          fs.copyFileSync(sourcePath, backupFilePath);
          backedUpFiles++;
        }
      }

      // Criar arquivo de informa√ß√µes do backup
      const backupInfo = {
        timestamp: new Date().toISOString(),
        version: this.version,
        installPath: this.installPath,
        backedUpFiles: backedUpFiles,
        reason: 'Hotfix v1.0.2.1 - Corre√ß√£o do sistema de licenciamento'
      };
      
      fs.writeFileSync(
        path.join(this.backupPath, 'backup-info.json'), 
        JSON.stringify(backupInfo, null, 2)
      );

      this.log(`Backup criado: ${this.backupPath}`, 'info');
      this.log(`${backedUpFiles} arquivos salvos no backup`, 'info');
      return true;
      
    } catch (error) {
      this.log(`Erro ao criar backup: ${error.message}`, 'error');
      return false;
    }
  }

  // üìÅ Copiar diret√≥rio recursivamente
  async copyDirectory(source, destination) {
    try {
      fs.mkdirSync(destination, { recursive: true });
      
      const items = fs.readdirSync(source);
      
      for (const item of items) {
        const sourcePath = path.join(source, item);
        const destPath = path.join(destination, item);
        
        const stat = fs.statSync(sourcePath);
        
        if (stat.isDirectory()) {
          await this.copyDirectory(sourcePath, destPath);
        } else {
          fs.copyFileSync(sourcePath, destPath);
        }
      }
    } catch (error) {
      throw new Error(`Erro ao copiar diret√≥rio: ${error.message}`);
    }
  }

  // üîç Encontrar arquivos espec√≠ficos no build Next.js
  findNextJSFiles() {
    this.log('Mapeando arquivos do build Next.js...', 'progress');
    
    const nextPath = path.join(this.installPath, '.next');
    const fileMap = new Map();
    
    try {
      // Encontrar layout.js
      const layoutPaths = [
        path.join(nextPath, 'server', 'app', 'layout.js'),
        path.join(nextPath, 'static', 'chunks', 'app', 'layout.js')
      ];
      
      for (const layoutPath of layoutPaths) {
        if (fs.existsSync(layoutPath)) {
          fileMap.set('layout', layoutPath);
          this.log(`Layout encontrado: ${path.relative(this.installPath, layoutPath)}`, 'info');
          break;
        }
      }

      // Encontrar arquivos de lib (license-manager)
      const libPath = path.join(nextPath, 'server', 'chunks');
      if (fs.existsSync(libPath)) {
        const chunkFiles = this.findFilesByContent(libPath, 'LicenseManager');
        if (chunkFiles.length > 0) {
          fileMap.set('license-manager', chunkFiles[0]);
          this.log(`License Manager encontrado: ${path.relative(this.installPath, chunkFiles[0])}`, 'info');
        }
      }

      return fileMap;
      
    } catch (error) {
      this.log(`Erro ao mapear arquivos: ${error.message}`, 'error');
      return new Map();
    }
  }

  // üîç Encontrar arquivos por conte√∫do
  findFilesByContent(directory, searchText, maxDepth = 3) {
    const results = [];
    
    if (maxDepth <= 0) return results;
    
    try {
      const items = fs.readdirSync(directory);
      
      for (const item of items) {
        const itemPath = path.join(directory, item);
        const stat = fs.statSync(itemPath);
        
        if (stat.isDirectory()) {
          results.push(...this.findFilesByContent(itemPath, searchText, maxDepth - 1));
        } else if (item.endsWith('.js')) {
          try {
            const content = fs.readFileSync(itemPath, 'utf8');
            if (content.includes(searchText)) {
              results.push(itemPath);
            }
          } catch (error) {
            // Ignorar arquivos que n√£o podem ser lidos
          }
        }
      }
    } catch (error) {
      // Ignorar diret√≥rios que n√£o podem ser lidos
    }
    
    return results;
  }

  // üîÑ Aplicar arquivos corrigidos
  async applyUpdates() {
    this.log('Aplicando corre√ß√µes...', 'progress');
    
    try {
      const fileMap = this.findNextJSFiles();
      let updatedFiles = 0;

      // Diret√≥rio onde est√£o os arquivos de corre√ß√£o
      const hotfixDir = path.join(__dirname, 'hotfix-files');
      
      if (!fs.existsSync(hotfixDir)) {
        throw new Error('Diret√≥rio de corre√ß√µes n√£o encontrado!');
      }

      // Aplicar Layout corrigido
      const layoutSource = path.join(hotfixDir, 'layout.js');
      const layoutTarget = fileMap.get('layout');
      
      if (fs.existsSync(layoutSource) && layoutTarget) {
        fs.copyFileSync(layoutSource, layoutTarget);
        updatedFiles++;
        this.log('Layout atualizado', 'info');
      }

      // Aplicar License Manager corrigido
      const licenseSource = path.join(hotfixDir, 'license-manager.js');
      const licenseTarget = fileMap.get('license-manager');
      
      if (fs.existsSync(licenseSource) && licenseTarget) {
        fs.copyFileSync(licenseSource, licenseTarget);
        updatedFiles++;
        this.log('License Manager atualizado', 'info');
      }

      // Adicionar License Recovery (novo arquivo)
      const recoverySource = path.join(hotfixDir, 'license-recovery.js');
      if (fs.existsSync(recoverySource) && licenseTarget) {
        // Inserir recovery no mesmo chunk do license manager
        const licenseContent = fs.readFileSync(licenseTarget, 'utf8');
        const recoveryContent = fs.readFileSync(recoverySource, 'utf8');
        
        // Combinar os arquivos
        const combinedContent = licenseContent + '\n\n' + recoveryContent;
        fs.writeFileSync(licenseTarget, combinedContent);
        updatedFiles++;
        this.log('License Recovery adicionado', 'info');
      }

      if (updatedFiles > 0) {
        this.log(`${updatedFiles} arquivos atualizados com sucesso`, 'info');
        return true;
      } else {
        throw new Error('Nenhum arquivo foi atualizado');
      }
      
    } catch (error) {
      this.log(`Erro ao aplicar atualiza√ß√µes: ${error.message}`, 'error');
      return false;
    }
  }

  // ‚úÖ Verificar se a atualiza√ß√£o funcionou
  async verifyUpdate() {
    this.log('Verificando se a atualiza√ß√£o funcionou...', 'progress');
    
    try {
      const fileMap = this.findNextJSFiles();
      
      // Verificar se os arquivos atualizados cont√™m as corre√ß√µes
      const layoutFile = fileMap.get('layout');
      const licenseFile = fileMap.get('license-manager');
      
      let verificationsPassed = 0;
      
      if (layoutFile && fs.existsSync(layoutFile)) {
        const layoutContent = fs.readFileSync(layoutFile, 'utf8');
        if (layoutContent.includes('checkEnvironmentBypass') || layoutContent.includes('LICENSE_VALID')) {
          verificationsPassed++;
          this.log('‚úì Layout com bypass detectado', 'info');
        }
      }
      
      if (licenseFile && fs.existsSync(licenseFile)) {
        const licenseContent = fs.readFileSync(licenseFile, 'utf8');
        if (licenseContent.includes('generateStableFingerprint') || licenseContent.includes('STABLE-')) {
          verificationsPassed++;
          this.log('‚úì Sistema de fingerprint est√°vel detectado', 'info');
        }
        if (licenseContent.includes('attemptSmartRecovery') || licenseContent.includes('RecoveryTools')) {
          verificationsPassed++;
          this.log('‚úì Sistema de recupera√ß√£o detectado', 'info');
        }
      }

      if (verificationsPassed >= 2) {
        this.log('‚úÖ Atualiza√ß√£o aplicada com sucesso!', 'info');
        return true;
      } else {
        this.log('‚ö†Ô∏è Atualiza√ß√£o pode n√£o ter sido aplicada corretamente', 'warning');
        return false;
      }
      
    } catch (error) {
      this.log(`Erro na verifica√ß√£o: ${error.message}`, 'error');
      return false;
    }
  }

  // üìä Gerar relat√≥rio final
  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      version: this.version,
      installPath: this.installPath,
      backupPath: this.backupPath,
      success: true,
      logs: this.logMessages
    };

    try {
      const reportPath = path.join(this.installPath, 'hotfix-report.json');
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      this.log(`Relat√≥rio salvo: ${reportPath}`, 'info');
    } catch (error) {
      this.log(`Aviso: N√£o foi poss√≠vel salvar relat√≥rio: ${error.message}`, 'warning');
    }

    return report;
  }

  // üöÄ Executar hotfix completo
  async run() {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                Representatives App - Hotfix v${this.version}               ‚ïë
‚ïë              Corre√ß√£o do Sistema de Licenciamento            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

    try {
      // Etapa 1: Detectar instala√ß√£o
      const installationFound = await this.detectInstallation();
      if (!installationFound) {
        process.exit(1);
      }

      // Etapa 2: Criar backup
      const backupCreated = await this.createBackup();
      if (!backupCreated) {
        this.log('‚ùå Falha ao criar backup. Interrompendo atualiza√ß√£o por seguran√ßa.', 'error');
        process.exit(1);
      }

      // Etapa 3: Aplicar corre√ß√µes
      const updatesApplied = await this.applyUpdates();
      if (!updatesApplied) {
        this.log('‚ùå Falha ao aplicar corre√ß√µes.', 'error');
        this.log('üíæ Backup dispon√≠vel em: ' + this.backupPath, 'info');
        process.exit(1);
      }

      // Etapa 4: Verificar
      const verificationPassed = await this.verifyUpdate();
      
      // Etapa 5: Relat√≥rio final
      this.generateReport();

      console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                      ‚úÖ HOTFIX CONCLU√çDO                      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üéØ O que foi corrigido:
   ‚Ä¢ Sistema de licenciamento est√°vel
   ‚Ä¢ Fingerprinting resistente a mudan√ßas
   ‚Ä¢ Comandos de recupera√ß√£o via console
   ‚Ä¢ Bypass autom√°tico quando configurado

üîß Pr√≥ximos passos:
   1. Reinicie o Representatives App
   2. O problema "Dispositivo alterado" foi resolvido
   3. Use F12 + Console: window.RepApp.help() para ver comandos

üìÅ Executado de: ${__dirname}
üíæ Backup criado em: ${this.backupPath}
üìã Instala√ß√£o: ${this.installPath}

${verificationPassed ? '‚úÖ Todas as verifica√ß√µes passaram!' : '‚ö†Ô∏è Algumas verifica√ß√µes falharam - teste o app'}
`);

    } catch (error) {
      this.log(`‚ùå Erro cr√≠tico: ${error.message}`, 'error');
      console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                      ‚ùå HOTFIX FALHOU                         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Entre em contato com o suporte t√©cnico com as informa√ß√µes acima.
${this.backupPath ? 'Backup dispon√≠vel em: ' + this.backupPath : ''}
`);
      process.exit(1);
    }
  }
}

// Executar hotfix se chamado diretamente
if (require.main === module) {
  const hotfix = new RepresentativesAppHotfix();
  hotfix.run().catch(console.error);
}

module.exports = RepresentativesAppHotfix;